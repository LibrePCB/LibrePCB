import { ComponentSignalListView } from "componentsignallistview.slint";
import { ComponentVariantListView } from "componentvariantlistview.slint";
import { Tab } from "../../tab.slint";
import {
    AttributesRowHeader,
    AuthorRowHeader,
    CategoriesRowCell,
    CategoriesRowHeader,
    DatasheetRowCell,
    DatasheetRowHeader,
    DefaultValueRowHeader,
    DeprecatedRowCell,
    DeprecatedRowHeader,
    DescriptionRowHeader,
    KeywordsRowHeader,
    MetadataFooterRowCell,
    NameRowHeader,
    PrefixRowHeader,
    SchematicOnlyRowHeader,
    VersionRowHeader,
} from "../metadatawidgets.slint";
import {
    BreakingChangesMessageBanner,
    CheckErrorsMessageBanner,
} from "../messagebanners.slint";
import {
    AttributeListView,
    Button,
    IconButton,
    LineEdit,
    LinkText,
    Palette,
    SlideView,
    Switch,
    TextEdit,
    TreeItemPickerPopup,
} from "../../widgets.slint";
import {
    Backend,
    ComponentTabData,
    Data,
    FeatureState,
    TabAction,
    WindowSectionData,
} from "../../api.slint";

component ComponentMetadataTab inherits GridLayout {
    in property <int> section-index;
    in-out property <[ComponentTabData]> tabs;
    in property <int> index;
    in property <bool> read-only;

    padding: 8px;
    spacing: 8px;

    Row {
        name-txt := NameRowHeader { }

        name-edt := LineEdit {
            text: tabs[index].name;
            validation-error: tabs[index].name-error;
            read-only: read-only;
            accessible-label: name-txt.text;

            init => {
                if (!read-only) && tabs[index].wizard-mode {
                    self.select-all();
                }
            }

            text-edited(text) => {
                tabs[index].name = text;
            }

            text-accepted(text) => {
                tabs[index].name = text;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        description-txt := DescriptionRowHeader { }

        description-edt := TextEdit {
            height: 100px;
            text: tabs[index].description;
            read-only: read-only;
            accessible-label: description-txt.text;

            text-edited(text) => {
                tabs[index].description = text;
            }

            text-accepted(text) => {
                tabs[index].description = text;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        keywords-txt := KeywordsRowHeader { }

        keywords-edt := LineEdit {
            text: tabs[index].keywords;
            read-only: read-only;
            accessible-label: keywords-txt.text;

            text-edited(text) => {
                tabs[index].keywords = text;
            }

            text-accepted(text) => {
                tabs[index].keywords = text;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        author-txt := AuthorRowHeader { }

        author-edt := LineEdit {
            text: tabs[index].author;
            read-only: read-only;
            accessible-label: author-txt.text;

            text-edited(text) => {
                tabs[index].author = text;
            }

            text-accepted(text) => {
                tabs[index].author = text;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        version-txt := VersionRowHeader { }

        version-edt := LineEdit {
            text: tabs[index].version;
            validation-error: tabs[index].version-error;
            read-only: read-only;
            accessible-label: version-txt.text;

            text-edited(text) => {
                tabs[index].version = text;
            }

            text-accepted(text) => {
                tabs[index].version = text;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        deprecated-txt := DeprecatedRowHeader { }

        deprecated-sw := DeprecatedRowCell {
            checked: tabs[index].deprecated;
            enabled: !read-only;
            accessible-label: deprecated-txt.text;

            toggled(checked) => {
                tabs[index].deprecated = checked;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        categories-txt := CategoriesRowHeader { }

        categories-cell := CategoriesRowCell {
            model: tabs[index].categories;
            read-only: read-only;
            accessible-label: categories-txt.text;

            add-triggered => {
                add-category-popup.show();
            }
        }
    }

    Row {
        datasheet-txt := DatasheetRowHeader { }

        datasheet-cell := DatasheetRowCell {
            url: tabs[index].datasheet-url;
            url-error: tabs[index].datasheet-url-error;
            read-only: read-only;
            label: datasheet-txt.text;

            text-edited(text) => {
                tabs[index].datasheet-url = text;
            }

            text-accepted(text) => {
                tabs[index].datasheet-url = text;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }

            open-url-clicked(url) => {
                Backend.trigger-tab(section-index, index, TabAction.open-datasheet);
            }
        }
    }

    Row {
        schematic-only-txt := SchematicOnlyRowHeader { }

        schematic-only-sw := Switch {
            font-size: 10px;
            text: @tr("Check this if this component cannot be placed on boards (e.g. supply symbols, sheet frames, ...).");
            checked: tabs[index].schematic-only;
            enabled: !read-only;
            accessible-label: schematic-only-txt.text;
            accessible-description: self.text;

            toggled(checked) => {
                tabs[index].schematic-only = checked;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        prefix-txt := PrefixRowHeader { }

        prefix-edt := LineEdit {
            text: tabs[index].prefix;
            validation-error: tabs[index].prefix-error;
            placeholder-text: @tr("E.g. \"{}\" for resistors, or \"{}\" for integrated circuits", "R", "U");
            read-only: read-only;
            accessible-label: prefix-txt.text;

            text-edited(text) => {
                tabs[index].prefix = text;
            }

            text-accepted(text) => {
                tabs[index].prefix = text;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        default-value-txt := DefaultValueRowHeader { }

        default-value-edt := TextEdit {
            text: tabs[index].default-value;
            validation-error: tabs[index].default-value-error;
            read-only: read-only;
            accessible-label: default-value-txt.text;
            accessible-placeholder-text: default-value-hint-txt.text;

            default-value-hint-l := GridLayout {
                padding: 8px;
                spacing-horizontal: 8px;
                spacing-vertical: 2px;
                visible: tabs[index].default-value.is-empty;

                Row {
                    default-value-hint-txt := Text {
                        colspan: 2;
                        color: #909090;
                        font-size: 11px;
                        wrap: word-wrap;
                        text: @tr("The VALUE the component gets when added to the schematics.");
                        accessible-role: none;
                    }
                }

                Row {
                    specific-txt := Text {
                        horizontal-stretch: 0;
                        overflow: elide;
                        color: #909090;
                        font-size: 11px;
                        text: @tr("For specific components (e.g. \"ESP32-S3R2\"):");
                        accessible-role: none;
                    }

                    specific-btn := LinkText {
                        horizontal-stretch: 1;
                        text-color: #c0c0c0;
                        font-size: 11px;
                        text: "{{MPN or DEVICE or COMPONENT}}";
                        accessible-description: specific-txt.text;

                        clicked => {
                            tabs[index].default-value = self.text;
                        }
                    }
                }

                Row {
                    generic-txt := Text {
                        horizontal-stretch: 0;
                        overflow: elide;
                        color: #909090;
                        font-size: 11px;
                        text: @tr("For generic components (e.g. \"OpAmp\"):");
                        accessible-role: none;
                    }

                    generic-btn := LinkText {
                        horizontal-stretch: 1;
                        text-color: #c0c0c0;
                        font-size: 11px;
                        text: "{{MPN or DEVICE}}";
                        accessible-description: generic-txt.text;

                        clicked => {
                            tabs[index].default-value = self.text;
                        }
                    }
                }
            }

            text-edited(text) => {
                tabs[index].default-value = text;
            }

            text-accepted(text) => {
                tabs[index].default-value = text;
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        attributes-txt := AttributesRowHeader { }

        attributes-view := AttributeListView {
            model: tabs[index].attributes;
            read-only: read-only;

            edited => {
                Backend.trigger-tab(section-index, index, TabAction.apply);
            }
        }
    }

    Row {
        Rectangle { }

        footer-cell := MetadataFooterRowCell {
            section-index: section-index;
            tab-index: index;
            wizard-mode: tabs[index].wizard-mode;
            unsaved-changes: Data.sections[section-index].tabs[index].unsaved-changes;
            checks: tabs[index].checks;
            read-only: read-only;
        }
    }

    Row {
        Rectangle { }
    }

    // Open the category chooser when requested by the backend.
    property <string> new-category: tabs[index].new-category;
    changed new-category => {
        if new-category == "choose" {
            add-category-popup.show();
        }
    }

    add-category-popup := TreeItemPickerPopup {
        width: parent.width;
        height: parent.height;
        model: tabs[index].categories-tree;
        icons-color: Palette.foreground;

        item-picked(idx, item) => {
            tabs[index].new-category = item.user-data;
        }
    }
}

component ComponentAddGatesTab inherits VerticalLayout {
    in property <int> section-index;
    in-out property <WindowSectionData> section;
    in-out property <[ComponentTabData]> tabs;
    in property <int> index;
    in property <bool> read-only;

    alignment: start;

    variants-view := ComponentVariantListView {
        model: tabs[index].variants;
        signal-names: tabs[index].signal-names;
        unit: tabs[index].unit;
        wizard-mode: true;
        read-only: read-only;

        render-scene(variant, gate, width, height, frame-dummy) => {
            Backend.render-scene(section-index, width, height, variant * 1000 + gate, frame-dummy)
        }

        add-variant-clicked => {
            Backend.trigger-tab(section-index, index, TabAction.component-add-variant);
        }
    }

    HorizontalLayout {
        alignment: start;
        padding: 8px;
        spacing: 8px;

        next-btn := Button {
            width: max(self.preferred-width, 100px);
            icon: @image-url("../../../../../font-awesome/svgs/solid/angle-right.svg");
            text: self.primary ? @tr("Next") : @tr("Skip");
            primary: tabs[index].variants[0].gates.length > 0;

            clicked => {
                Backend.trigger-tab(section-index, index, TabAction.next);
            }
        }

        back-btn := Button {
            width: self.preferred-width;
            icon: @image-url("../../../../../font-awesome/svgs/solid/angle-left.svg");
            text: @tr("Back");

            clicked => {
                Backend.trigger-tab(section-index, index, TabAction.back);
            }
        }
    }
}

component ComponentSignalsEditorTab inherits VerticalLayout {
    in property <int> section-index;
    in-out property <WindowSectionData> section;
    in-out property <[ComponentTabData]> tabs;
    in property <int> index;
    in property <bool> read-only;

    alignment: start;
    padding-left: 8px;
    padding-top: 8px;
    spacing: 10px;

    callback focus-rejected <=> signals-view.focus-rejected;

    if !read-only: Rectangle {
        background: #454545;
        border-radius: 10px;

        VerticalLayout {
            padding: 8px;
            spacing: 8px;

            if tabs[index].wizard-mode: Text {
                property <string> s1: @tr("Now review & correct the list of signals, if needed (often it is not needed, then just proceed).");
                property <string> s2: @tr("If you add or remove any signals, don't forget to update the pinout afterwards (on the next step)!");

                wrap: word-wrap;
                text: s1 + " " + s2;
            }

            Text {
                property <string> s1: @tr("This signal list should represent the *electrical* interface of the component, not the *mechanical* pads.");
                property <string> s2: @tr("For example, if an IC has two or more GND pads which are internally connected, only one GND signal should be added here.");
                property <string> s3: @tr("Note that once the component is finished, it is *not* possible anymore to add or remove signals.");

                font-size: 11px;
                font-italic: true;
                wrap: word-wrap;
                text: @tr("Important:") + " " + s1 + " " + s2 + " " + s3;
            }
        }
    }

    if !read-only: HorizontalLayout {
        padding-right: 8px;
        spacing: 5px;

        new-signal-txt := Text {
            vertical-alignment: center;
            text: @tr("Add Signals:");
            accessible-role: none;
        }

        new-signal-edt := LineEdit {
            placeholder-text: @tr("Signal name (may contain ranges like \"1..5\"; use prefix \"!\" for inverted signals)");
            text: tabs[index].new-signal-name;
            validation-error: tabs[index].new-signal-name-error;
            accessible-label: new-signal-txt.text;

            text-edited(text) => {
                tabs[index].new-signal-name = text;
            }

            key-pressed(event) => {
                if event.text == Key.Return {
                    new-signal-btn.clicked();
                    return accept;
                }
                reject
            }
        }

        new-signal-btn := IconButton {
            style: hyperlink;
            icon-scale: 0.65;
            icon: @image-url("../../../../../font-awesome/svgs/solid/plus.svg");
            enabled: !new-signal-edt.text.is-empty;
            accessible-label: "add signal";

            clicked => {
                Backend.trigger-tab(section-index, index, TabAction.component-add-signals);
            }
        }
    }

    signals-view := ComponentSignalListView {
        model: tabs[index].cmp-signals;
        read-only: read-only;

        edited => {
            Backend.trigger-tab(section-index, index, TabAction.apply);
        }
    }

    if tabs[index].wizard-mode: HorizontalLayout {
        alignment: start;
        padding: 8px;
        spacing: 8px;

        next-btn := Button {
            width: max(self.preferred-width, 100px);
            primary: true;
            icon: @image-url("../../../../../font-awesome/svgs/solid/check.svg");
            text: @tr("Finish");

            clicked => {
                Backend.trigger-tab(section-index, index, TabAction.next);
            }
        }

        back-btn := Button {
            width: self.preferred-width;
            icon: @image-url("../../../../../font-awesome/svgs/solid/angle-left.svg");
            text: @tr("Back");

            clicked => {
                Backend.trigger-tab(section-index, index, TabAction.back);
            }
        }
    }
}

export component ComponentTab inherits Tab {
    in property <int> section-index;
    in-out property <WindowSectionData> section;
    property <[ComponentTabData]> tabs: section.component-tabs;
    property <int> index: section.current-tab-index;
    property <bool> read-only: section.tabs[index].features.save != FeatureState.enabled;

    enabled: true;

    VerticalLayout {
        BreakingChangesMessageBanner {
            shown: tabs[index].interface-broken-msg;
        }

        CheckErrorsMessageBanner {
            shown: tabs[index].checks.errors > 0;
        }

        // Wizard mode: Only one page at a time.
        if tabs[index].wizard-mode && (tabs[index].page-index <= 0): metadata-tab-1 := ComponentMetadataTab {
            section-index: section-index;
            tabs: tabs;
            index: index;
            read-only: read-only;
        }
        if tabs[index].wizard-mode && (tabs[index].page-index == 1): add-gates-tab := ComponentAddGatesTab {
            section-index: section-index;
            tabs: tabs;
            index: index;
        }
        if tabs[index].wizard-mode && (tabs[index].page-index >= 2): signals-tab-1 := ComponentSignalsEditorTab {
            section-index: section-index;
            tabs: tabs;
            index: index;
            read-only: read-only;

            focus-rejected => {
                root.focus();
            }
        }

        // Normal mode: Slide between metadata, signals and variants.
        if !tabs[index].wizard-mode: SlideView {
            pages: [
                // In wizard mode: Metadata, Add Gates, Signals
                { title: @tr("Metadata") },
                { title: @tr("Signals") },
                { title: @tr("Variants & Gates") },
            ];
            current-index: tabs[index].page-index;

            metadata-tab-2 := ComponentMetadataTab {
                width: parent.width;
                section-index: section-index;
                tabs: tabs;
                index: index;
                read-only: read-only;
            }

            signals-tab-2 := ComponentSignalsEditorTab {
                width: parent.width;
                section-index: section-index;
                tabs: tabs;
                index: index;
                read-only: read-only;

                focus-rejected => {
                    root.focus();
                }
            }

            variants-tab := ComponentVariantListView {
                width: parent.width;
                model: tabs[index].variants;
                signal-names: tabs[index].signal-names;
                unit: tabs[index].unit;
                wizard-mode: false;
                read-only: read-only;

                render-scene(variant, gate, width, height, frame-dummy) => {
                    Backend.render-scene(section-index, width, height, variant * 1000 + gate, frame-dummy)
                }

                add-variant-clicked => {
                    Backend.trigger-tab(section-index, index, TabAction.component-add-variant);
                }
            }

            page-clicked(idx) => {
                tabs[index].page-index = idx;
            }
        }
    }
}
